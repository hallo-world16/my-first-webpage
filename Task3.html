<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Matching Game</title>
    <style>
        /* Add your CSS styles here */
    </style>
</head>
<body>
    <h1>Match the Terms with their Definitions</h1>
    <div class="score">Score: <span id="score">0</span> / 5</div>
    <div class="container">
        <div class="terms">
            <h2>Terms</h2>
        </div>
        <div class="definitions">
            <h2>Definitions</h2>
        </div>
    </div>
    <button onclick="checkAnswers()">Check Answers</button>
    <button onclick="resetGame()">Reset</button>
    <div class="matches" id="matches"></div>

    <script>
        const data = [
            { term: "Photosynthesis", definition: "Process where plants convert sunlight into energy" },
            { term: "Mitochondria", definition: "Powerhouse of the cell" },
            { term: "DNA", definition: "Carries genetic information in living things" },
            { term: "Cell Membrane", definition: "Barrier that controls what enters and exits the cell" },
            { term: "Nucleus", definition: "Control center of the cell containing genetic material" }
        ];

        let matches = new Map();
        let score = 0;
        let selectedTerm = null;
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function loadGame() {
            const termsDiv = document.querySelector('.terms');
            const definitionsDiv = document.querySelector('.definitions');
            
            // Shuffle terms and definitions independently
            const termIndices = [...data.keys()];
            const defIndices = [...data.keys()];
            shuffle(termIndices);
            shuffle(defIndices);

            termsDiv.innerHTML = '<h2>Terms</h2>';
            defIndices.forEach(originalIndex => {
                const term = data[originalIndex].term;
                termsDiv.innerHTML += `
                    <div class="item" draggable="${!isTouchDevice}" 
                        data-id="${originalIndex + 1}" 
                        tabindex="0"
                        aria-label="Term: ${term}">
                        ${term}
                    </div>
                `;
            });

            definitionsDiv.innerHTML = '<h2>Definitions</h2>';
            defIndices.forEach(originalIndex => {
                const definition = data[originalIndex].definition;
                definitionsDiv.innerHTML += `
                    <div class="item" 
                        data-match="${originalIndex + 1}"
                        tabindex="0"
                        aria-label="Definition: ${definition}">
                        ${definition}
                    </div>
                `;
            });

            setupEventListeners();
        }

        function setupEventListeners() {
            // Clear existing listeners
            const terms = document.querySelectorAll('.terms .item');
            const definitions = document.querySelectorAll('.definitions .item');

            terms.forEach(term => {
                term.replaceWith(term.cloneNode(true));
            });
            definitions.forEach(def => {
                def.replaceWith(def.cloneNode(true));
            });

            // Set up new listeners
            if (isTouchDevice) {
                document.querySelectorAll('.terms .item').forEach(item => {
                    item.addEventListener('click', handleTermClick);
                    item.addEventListener('keydown', handleKeyDown);
                });
                document.querySelectorAll('.definitions .item').forEach(item => {
                    item.addEventListener('click', handleDefClick);
                    item.addEventListener('keydown', handleKeyDown);
                });
            } else {
                document.querySelectorAll('.terms .item').forEach(item => {
                    item.addEventListener('dragstart', handleDragStart);
                    item.addEventListener('dragend', handleDragEnd);
                    item.addEventListener('keydown', handleKeyDown);
                });
                document.querySelectorAll('.definitions .item').forEach(item => {
                    item.addEventListener('dragover', handleDragOver);
                    item.addEventListener('drop', handleDrop);
                    item.addEventListener('dragleave', handleDragLeave);
                    item.addEventListener('keydown', handleKeyDown);
                });
            }
        }

        function handleTermClick() {
            if (selectedTerm) selectedTerm.classList.remove('selected');
            selectedTerm = this;
            this.classList.add('selected');
        }

        function handleDefClick() {
            if (!selectedTerm) return;
            
            const termId = selectedTerm.dataset.id;
            const defMatch = this.dataset.match;

            // Remove existing matches
            matches.delete(termId);
            matches.forEach((value, key) => {
                if (value === defMatch) matches.delete(key);
            });

            matches.set(termId, defMatch);
            updateMatches();
            selectedTerm.classList.remove('selected');
            selectedTerm = null;
        }

        function handleDragStart(e) {
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', '');
        }

        function handleDragEnd() {
            this.classList.remove('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
            this.classList.add('dragover');
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragLeave() {
            this.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('dragover');
            const term = document.querySelector('.terms .item.dragging');
            if (!term) return;

            const termId = term.dataset.id;
            const defMatch = this.dataset.match;

            matches.delete(termId);
            matches.forEach((value, key) => {
                if (value === defMatch) matches.delete(key);
            });

            matches.set(termId, defMatch);
            updateMatches();
        }

        function handleKeyDown(e) {
            if (e.key === 'Enter') {
                if (this.closest('.terms')) handleTermClick.call(this, e);
                else if (selectedTerm) handleDefClick.call(this, e);
            }
        }

        function updateMatches() {
            const matchesDiv = document.getElementById('matches');
            matchesDiv.innerHTML = '';
            matches.forEach((defId, termId) => {
                const term = document.querySelector(`.terms .item[data-id="${termId}"]`);
                const def = document.querySelector(`.definitions .item[data-match="${defId}"]`);
                if (term && def) {
                    matchesDiv.innerHTML += `
                        <div class="match-pair">
                            <div>${term.textContent}</div>
                            <div>${def.textContent}</div>
                        </div>
                    `;
                }
            });
        }

        function checkAnswers() {
            score = 0;
            document.querySelectorAll('.item').forEach(item => {
                item.classList.remove('correct', 'incorrect');
            });

            matches.forEach((defId, termId) => {
                const term = document.querySelector(`.terms .item[data-id="${termId}"]`);
                const def = document.querySelector(`.definitions .item[data-match="${defId}"]`);
                
                if (termId === defId) {
                    term.classList.add('correct');
                    def.classList.add('correct');
                    score++;
                } else {
                    term.classList.add('incorrect');
                    def.classList.add('incorrect');
                }
            });

            document.getElementById('score').textContent = score;
            if (score === data.length) alert("Perfect! All matches correct!");
        }

        function resetGame() {
            matches.clear();
            document.getElementById('matches').innerHTML = '';
            document.querySelectorAll('.item').forEach(item => {
                item.classList.remove('correct', 'incorrect', 'selected');
            });
            score = 0;
            document.getElementById('score').textContent = score;
            loadGame();
        }

        // Initialize game
        loadGame();
    </script>
</body>
</html>
